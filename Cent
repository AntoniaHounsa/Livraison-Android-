
export function withApiHandling(options) {
  return (source$) => source$.pipe(
    tap((res) => {
      if (options.successMessage) notifier.success(options.successMessage);
      if (options.successRedirectTo) router.navigate(options.successRedirectTo);
    }),
    catchError((err) => {
      notifier.error(options.errorMessage || err.message);
      return throwError(() => err);
    }),
    finalize(() => options.finally?.())
  );
}

this.http.post('/api/users', this.form.value).pipe(
  withApiHandling({
    successMessage: 'Utilisateur crÃ©Ã© avec succÃ¨s !'
  })
).subscribe();





Parfait ğŸŒŸ tu as trÃ¨s bien cernÃ© ton besoin.
Voici la rÃ©daction de ton issue GitLab structurÃ©e proprement selon les trois sections que tu veux :
â†’ SpÃ©cification du besoin (User Story)
â†’ SpÃ©cification fonctionnelle
â†’ SpÃ©cification technique

Aucune ligne de code, uniquement ce quâ€™il faut pour la validation Ã©quipe.

â¸»

ğŸ§¾ Issue : Uniformisation de la gestion des erreurs API

â¸»

ğŸ§  SpÃ©cification du besoin (User Story)

En tant que dÃ©veloppeuse front,
je souhaite que la gestion des erreurs et des succÃ¨s API soit centralisÃ©e et homogÃ¨ne Ã  travers toute lâ€™application,
afin de :
	â€¢	Ã©viter la rÃ©pÃ©tition de logique dâ€™affichage (toasts, redirections, etc.) dans chaque composant,
	â€¢	garantir une expÃ©rience utilisateur cohÃ©rente quelle que soit la page,
	â€¢	et faciliter la maintenance du code en centralisant les comportements standards.

CritÃ¨res dâ€™acceptation :
	â€¢	La gestion des erreurs est uniforme sur tous les modules.
	â€¢	Les redirections automatiques et messages de feedback sont cohÃ©rents selon le code HTTP.
	â€¢	Les dÃ©veloppeurs peuvent personnaliser facilement les comportements pour un cas spÃ©cifique (message, redirectionâ€¦).
	â€¢	Aucun composant nâ€™a besoin de gÃ©rer manuellement un alert() ou une redirection API.

â¸»

âš™ï¸ SpÃ©cification fonctionnelle

Objectif gÃ©nÃ©ral :
Centraliser la gestion des retours API (succÃ¨s et erreurs) dans la lib partagÃ©e, afin dâ€™appliquer des rÃ¨gles communes Ã  toutes les applications Angular du monorepo.

Cas Ã  gÃ©rer

Cas	Message utilisateur	Action complÃ©mentaire
200 / 201	â€œAction effectuÃ©e avec succÃ¨sâ€	PossibilitÃ© de redirection personnalisÃ©e selon le contexte (ex : vers la ressource crÃ©Ã©e).
401 (Non autorisÃ©)	â€œVotre session a expirÃ©.â€	Redirection automatique vers /login.
403 (AccÃ¨s refusÃ©)	â€œAccÃ¨s refusÃ©.â€	Redirection automatique vers /forbidden.
422 (Erreur de validation)	Pas de message global.	Gestion spÃ©cifique au niveau du formulaire (affichage des erreurs champ par champ).
500+ (Erreur serveur)	â€œUne erreur interne est survenue.â€	Aucun dÃ©tail technique affichÃ©.
0 (Erreur rÃ©seau)	â€œConnexion rÃ©seau indisponible.â€	Aucun redirect, simple notification.

Attendus fonctionnels
	â€¢	Lâ€™affichage des toasts doit Ãªtre automatique et cohÃ©rent pour tous les modules.
	â€¢	Les redirections doivent Ãªtre automatiques pour les statuts 401 et 403.
	â€¢	Les erreurs de validation (422) doivent pouvoir Ãªtre transmises Ã  un gestionnaire local de formulaire.
	â€¢	Le dÃ©veloppeur doit pouvoir surcharger le comportement dans un cas prÃ©cis :
	â€¢	personnaliser le message de succÃ¨s ou dâ€™erreur ;
	â€¢	rediriger vers une page dynamique aprÃ¨s succÃ¨s (ex : /users/:id);
	â€¢	exÃ©cuter une fonction personnalisÃ©e Ã  la fin dâ€™un appel (ex : reset spinner).
	â€¢	Tous les messages doivent Ãªtre en franÃ§ais et comprÃ©hensibles par lâ€™utilisateur final.

â¸»

ğŸ§© SpÃ©cification technique

PÃ©rimÃ¨tre :
	â€¢	ImplÃ©mentation dans la lib partagÃ©e (@org/shared/api-handling ou Ã©quivalent).
	â€¢	Application Ã  toutes les requÃªtes rÃ©alisÃ©es via HttpClient.
	â€¢	Aucun composant spÃ©cifique nâ€™aura Ã  gÃ©rer directement les erreurs API.

Architecture technique cible
	1.	HttpInterceptor
	â€¢	Capture toutes les erreurs HTTP (4xx, 5xx, etc.).
	â€¢	GÃ¨re les cas globaux (401, 403, 500, 0).
	â€¢	Normalise les erreurs sous un modÃ¨le commun (status, message, details?).
	â€¢	Laisse les flux remonter pour traitement complÃ©mentaire si nÃ©cessaire.
	2.	Service de notification (Notifier)
	â€¢	Interface commune pour afficher les toasts (implÃ©mentation basÃ©e sur Angular Material ou autre lib).
	â€¢	Accessible depuis la lib via injection de dÃ©pendance.
	3.	OpÃ©rateur RxJS withApiHandling()
	â€¢	Point dâ€™entrÃ©e principal pour le dÃ©veloppeur.
	â€¢	Permet de passer des options personnalisÃ©es par appel :
	â€¢	message de succÃ¨s / dâ€™erreur (statique ou dynamique) ;
	â€¢	redirection en cas de succÃ¨s / dâ€™Ã©chec ;
	â€¢	fonction de gestion dâ€™erreurs de champ (pour les 422) ;
	â€¢	callback finally() pour relÃ¢cher les Ã©tats de chargement.
	â€¢	Cet opÃ©rateur appliquera la logique standard tout en laissant la flexibilitÃ© de surcharger.
	4.	Configurable & rÃ©utilisable
	â€¢	Par dÃ©faut, les comportements standards (messages, redirections, statut codes) seront dÃ©finis dans la lib.
	â€¢	Chaque application pourra les surcharger via configuration si nÃ©cessaire.

RÃ©sultat attendu
	â€¢	Tous les modules bÃ©nÃ©ficient automatiquement du mÃªme comportement en cas dâ€™erreur ou de succÃ¨s API.
	â€¢	Chaque feature peut personnaliser son comportement localement sans casser la logique globale.
	â€¢	La maintenance et lâ€™Ã©volution des rÃ¨gles de gestion se font dans un seul endroit (lib partagÃ©e).
	â€¢	Le code mÃ©tier dans les composants reste simple et lisible (pas de catchError, alert(), etc.).

â¸»

Souhaites-tu que je tâ€™en fasse aussi la version Markdown prÃªte Ã  copier-coller pour GitLab (avec titres ###, tableaux bien alignÃ©s et un format plus â€œGitLab Issue Templateâ€) ?
Ã‡a te permettrait de la dÃ©poser directement dans ton repo sans reformater.
